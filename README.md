# CS-350-Emerging-Systems-Architectures-Technologies

<b>Summarize the project and what problem it was solving.</b>

Systec is a company that develops analytics software for servers. The purpose of the project was to create the prototype for a smart thermostat using a microcontroller from Texas Instrument that sends data to SysTec’s server software over Wi-Fi. Additionally, the work performed in this project served to recommend and justify an appropriate hardware architecture for the next phase of the project. The prototype reads data from a built-in temperature sensor every 500ms and communicates that value through an inter-integrated circuit (I2C) serial communication bus. General purpose input/output (GPIO) allow a red LED to activate when the room temperature is less than the set-point temperature and turn off when the room temperature is greater than or equal to the set-point temperature. The set-point temperature can be increased and/or decreased by pressing the buttons on the left and right side of the board. The application’s code checks whether either button has been pressed every 200ms using GPIO interrupts. Every second, the universal asynchronous receiver-transmitter (UART) outputs the value of the current temperature, set-point temperature, whether the red LED is on or off, and how many seconds have passed since the board has been reset. The business requirements for the project were that the thermostat needed to support the communication protocols UART, I2C, and GPIO, connect to the cloud via Wi-Fi, and have enough Flash memory and RAM to support the project’s code. The problem that the project was solving is determining the appropriate hardware architecture to fulfill Systec’s needs and initiate Systec’s presence within the global smart thermostat market.

<b>What did you do particularly well?</b>

I think I did particularly well in implementing and explaining the task scheduler functionality within the project. I initially had difficulty understanding the purpose of raising and lowering a global flag, but after Milestone Three I realized that they are used to indicate that a period of time has been reached so that certain instructions can executed before waiting for the period to be reached again. Through this project I have been able to create a program that efficiently performs multiple tasks at various timer intervals.

<b>Where could you improve?</b>

	I think that my code could be improved by using the timer callback function to execute the task functionality instead of only raising the global flag. This could improve the readability and maintainability of my code. I also think that I could improve by removing the switch cases within the third task, OutputToServer, that outputs data to the server. This would make my code more efficient as the use of switch cases is redundant in hindsight. However, it was easier for me to create the state diagram by using a state machine for each of the three tasks. 
  
<b>What tools and/or resources are you adding to your support network?</b>

	The driver documentation provided by Texas Instrument was significantly helpful throughout. The reference files for drivers are resources that I am adding to my support network for future projects, whether for an embedded system or not. I am also in contact with a few students from the course who I can consider resources. Code composer studio is a tool that I am adding to my support network should I ever develop another application for a Texas Instruments embedded processor.  
  
<b>What skills from this project will be particularly transferable to other projects and/or course work?</b>

This course/project was my first experience with writing interface software to control hardware components, as well with writing code in C. These skills from the project will be particularly transferable to other projects when working on developing an embedded system or application written in C. This project required a lot of research and collaboration with other students through the general discussion thread to fulfill the technical requirements. These are valuable skills for much of the remaining course work I have at SNHU, as well as professionally in my future career. Interpreting technical and business requirements are essential skills from this project that I will be able to transfer to every project in the future as a software engineer. 

<b>How did you make this project maintainable, readable, and adaptable?</b>

One of the ways that I made this project maintainable, readable, and adaptable was by not using magic numbers. Instead, I defined constants using macros which makes it easier for other developers to infer the logic within the code. It also makes it easier to adapt should any of the values change during future iterations of the code. Only the macro needs to be redefined rather than replacing all values of magic numbers used. Another way that I made this project maintainable, readable, and adaptable was by defining and separating the smart thermostat’s functionality into tasks. Creating a task structure simplifies the process of adding more functionality to the program should Systec wish to extend the smart thermostat’s capabilities. All that would really need to be done is to add the new task(s) to the list of tasks, define a tick function, and set the period. The task scheduler functionality within the infinite loop of the main thread also improved the project’s maintainability, readability, and adaptability because the same code is used to iterate through and execute tasks. Adding more tasks would not necessarily require any of the code in the infinite loop to change; its adaptable to new functionality. 
